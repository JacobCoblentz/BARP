#' BARP
#' 
#' This function uses Bayesian Additive Regression Trees (BART) to extrapolate survey data to a level of geographic aggregation at which the original survey was not sampled to be representative of.
#' @param y Outcome of interest. Should be a character of the column name containing the variable of interest.
#' @param x Prognostic covariates. Should be a vector of column names corresponding to the covariates used to predict the outcome variable of interest.
#' @param dat Survey data containing the x and y column names.
#' @param census Census data containing the x column names. If the user provides raw census data, BARP will calculate proportions for each unique bin of x covariates. Otherwise, the researcher must calculate bin proportions and indicate the column name that contains the proportions, either as percentages or as raw counts.
#' @param geo.unit The column name corresponding to the unit at which outcomes should be aggregated.
#' @param plot_convergence Plot convergence diagnostics calculated by bartMachine. Defaults to \code{TRUE}.
#' @param proportion The column name corresponding to the proportions for covariate bins in the Census data. If left to the default \code{None} value, BARP assumes raw census data and estimates bin proportions automatically.
#' @param cred_int A vector giving the lower and upper bounds on the credible interval for the predictions.
#' @param BSSD Calculate bootstrapped standard deviation. Defaults to \code{FALSE} in which case the standard deviation is generated by BART's default.
#' @param nsims The number of bootstrap simulations. 
#' @param ... Additional arguments to be passed to bartMachine.
#' @return Returns an object of class ``BARP'', containing a list of the following components:
#' \item{pred.opn}{A \code{data.frame} where each row corresponds to the geographic unit of interest and the columns summarize the predicted outcome and the upper and lower bounds for the given credible interval (\code{cred_int}).}
#' \item{trees}{A \code{bartMachine} object. See \code{\link{bartMachine}} for details.}
#' @keywords MRP BARP Mister P multilevel regression poststratification
#' @seealso \code{\link{bartMachine}} which this program uses to implement Bayesian Additive Regression Trees.
#' @examples 
#' data("gaymar")
#' barp <- barp(y = "supp_gaymar",
#'              x = c("pvote","religcon","age","educ","gXr","stateid","region"),
#'              dat = svy,
#'              census = census06,
#'              geo.unit = "stateid",
#'              proportion = "n",
#'              cred_int = c(0.025,0.975))
#' @export

barp <- function(y,x,dat,census,geo.unit,
                 proportion = "None",cred_int = c(0.025,0.975),BSSD = F,nsims = 20,...) {
  if(!all(x %in% colnames(dat))) {
    stop(paste("Variable '",x[which(!(x %in% colnames(dat)))],"' is not in your survey data.",sep=""))
  }
  if(!all(x %in% colnames(census))) {
    stop(paste("Variable '",x[which(!(x %in% colnames(census)))],"' is not in your census data.",sep=""))
  }
  if(!(y %in% colnames(dat))) {
    stop(paste("Outcome '",y,"' is not in your survey data.",sep=""))
  }
  if(!(geo.unit %in% x)) {
    stop(paste("The geographic unit '",geo.unit,"' is not among your x controls.",sep=""))
  }
  if(proportion == "None") {
    census <- census %>% group_by_(.dots = x) %>% summarise(n = n())
  } else {
    census$n <- census[[proportion]]
  }
  if(BSSD) {
    barp.geo.tmp <- matrix(NA,nrow = length(unique(census[[geo.unit]])),ncol = nsims)
    for(i in 1:nsims) {
      inds <- sample(1:nrow(dat),replace = T)
      x.train <- dat[,which(colnames(dat) %in% x)]
      y.train <- dat[,which(colnames(dat) %in% y)]
      x.test <- census[,which(colnames(census) %in% x)]
      trees <- .javaMem(bartMachine(x.train,y.train,...))
      p <- predict(trees,x.test,type = "prob")
      barp.dat <- as.data.frame(cbind(census,p))
      barp.geo.tmp[,i] <- as.vector(sapply(unique(census[[geo.unit]]),
                       function(j) sum(barp.dat$n[barp.dat[[geo.unit]]==j]*barp.dat$p[barp.dat[[geo.unit]]==j])/sum(barp.dat$n[barp.dat[[geo.unit]]==j])))
    }
    y.pred <- apply(barp.geo.tmp,1,mean)
    y.lb <- apply(barp.geo.tmp,1,quantile,cred_int[1])
    y.ub <- apply(barp.geo.tmp,1,quantile,cred_int[2])
    barp.geo <- data.frame("geo.unit" = unique(census[[geo.unit]]),"pred.opn" = y.pred,"opn.lb" = y.lb,"opn.ub" = y.ub)
    x.train <- dat[,which(colnames(dat) %in% x)]
    y.train <- dat[,which(colnames(dat) %in% y)]
    x.test <- census[,which(colnames(census) %in% x)]
    trees <- .javaMem(bartMachine(x.train,y.train,...))
  } else {
    x.train <- dat[,which(colnames(dat) %in% x)]
    y.train <- dat[,which(colnames(dat) %in% y)]
    x.test <- census[,which(colnames(census) %in% x)]
    trees <- .javaMem(bartMachine(x.train,y.train,...))
    ints <- calc_credible_intervals(trees,x.test)
    p <- predict(trees,x.test,type = "prob")
    barp.dat <- as.data.frame(cbind(census,p,ints))
    y.pred<-sapply(unique(census[[geo.unit]]),
                     function(j) sum(barp.dat$n[barp.dat[[geo.unit]]==j]*barp.dat$p[barp.dat[[geo.unit]]==j])/sum(barp.dat$n[barp.dat[[geo.unit]]==j]))
    y.lb<-sapply(unique(census[[geo.unit]]),
                   function(j) sum(barp.dat$n[barp.dat[[geo.unit]]==j]*barp.dat$ci_lower_bd[barp.dat[[geo.unit]]==j])/sum(barp.dat$n[barp.dat[[geo.unit]]==j]))
    y.ub<-sapply(unique(census[[geo.unit]]),
                 function(j) sum(barp.dat$n[barp.dat[[geo.unit]]==j]*barp.dat$ci_upper_bd[barp.dat[[geo.unit]]==j])/sum(barp.dat$n[barp.dat[[geo.unit]]==j]))
    barp.geo <- data.frame("geo.unit" = unique(census[[geo.unit]]),"pred.opn" = y.pred,"opn.lb" = y.lb,"opn.ub" = y.ub)
  }
  colnames(barp.geo)[1] <- geo.unit
  barp.obj <- list("pred.opn" = barp.geo,"trees" = trees)
  class(barp.obj) <- "brp"
  return(barp.obj)
}
